generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// CORE ACCOUNTING - Double-Entry Ledger with Hash Chain
// ============================================================================

model JournalEntry {
  id          String   @id @default(cuid())
  date        DateTime
  description String
  reference   String?

  // Hash chain for immutability (SHA-256)
  hash     String  @unique
  prevHash String?

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  postings         Posting[]
  blockchainEvents BlockchainEvent[]
  sourceLots       Lot[]             @relation("LotSource")
  lotDisposals     LotDisposal[]     @relation("LotDisposal")
  invoices         Invoice[]
  bankTransactions BankTransaction[]

  @@index([date])
  @@index([hash])
  @@index([createdAt])
}

model Posting {
  id        String @id @default(cuid())
  entryId   String
  accountId String

  debit       Float   @default(0)
  credit      Float   @default(0)
  description String?

  metadata Json @default("{}")

  entry      JournalEntry       @relation(fields: [entryId], references: [id], onDelete: Cascade)
  account    Account            @relation(fields: [accountId], references: [id])
  dimensions PostingDimension[]

  @@index([entryId])
  @@index([accountId])
}

model Account {
  id   String @id @default(cuid())
  code String @unique
  name String
  type String // "asset", "liability", "equity", "revenue", "expense"

  parentId String?
  isActive Boolean @default(true)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent          Account?          @relation("AccountHierarchy", fields: [parentId], references: [id])
  children        Account[]         @relation("AccountHierarchy")
  postings        Posting[]
  entityId        String?
  entity          Entity?           @relation(fields: [entityId], references: [id])
  bankAccounts    BankAccount[]
  AccountSnapshot AccountSnapshot[]

  @@index([code])
  @@index([type])
  @@index([parentId])
}

// ============================================================================
// DIMENSIONAL ACCOUNTING - 7 First-Class Dimensions
// ============================================================================

model Dimension {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  description String?

  isActive Boolean @default(true)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  values DimensionValue[]

  @@index([code])
}

model DimensionValue {
  id          String  @id @default(cuid())
  dimensionId String
  code        String
  name        String
  description String?

  isActive Boolean @default(true)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  dimension Dimension          @relation(fields: [dimensionId], references: [id], onDelete: Cascade)
  postings  PostingDimension[]

  @@unique([dimensionId, code])
  @@index([dimensionId])
  @@index([code])
}

model PostingDimension {
  id               String @id @default(cuid())
  postingId        String
  dimensionValueId String

  posting        Posting        @relation(fields: [postingId], references: [id], onDelete: Cascade)
  dimensionValue DimensionValue @relation(fields: [dimensionValueId], references: [id], onDelete: Cascade)

  @@unique([postingId, dimensionValueId])
  @@index([postingId])
  @@index([dimensionValueId])
}

// ============================================================================
// SNAPSHOTS - Point-in-Time Balance Storage
// ============================================================================

model AccountSnapshot {
  id        String   @id @default(cuid())
  accountId String
  asOfDate  DateTime

  debit   Float
  credit  Float
  balance Float

  createdAt DateTime @default(now())

  account Account @relation(fields: [accountId], references: [id])

  @@unique([accountId, asOfDate])
  @@index([asOfDate])
}

model DimensionalSnapshot {
  id        String   @id @default(cuid())
  accountId String
  asOfDate  DateTime

  dimensions Json // { "legal_entity": "US-001", "cost_center": "CC-SALES" }

  debit   Float
  credit  Float
  balance Float

  createdAt DateTime @default(now())

  @@index([accountId, asOfDate])
  @@index([asOfDate])
}

// ============================================================================
// BLOCKCHAIN INTEGRATION - Ethereum Event Indexing
// ============================================================================

model BlockchainEvent {
  id      String @id @default(cuid())
  chain   String // "ethereum", "polygon", "arbitrum"
  network String // "mainnet", "goerli", "sepolia"

  // Transaction details
  txHash         String
  blockNumber    BigInt
  blockTimestamp DateTime
  logIndex       Int

  // Event details
  eventType    String // "transfer", "swap", "approval"
  from         String // Address
  to           String // Address
  asset        String? // Token symbol or "ETH"
  tokenAddress String? // ERC-20 contract address
  quantity     Float

  // Fees
  feeAmount   Float  @default(0)
  feeCurrency String @default("ETH")

  // Processing
  processed      Boolean @default(false)
  classifiedAs   String? // "deposit", "withdrawal", "trade", etc.
  journalEntryId String?

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  journalEntry JournalEntry? @relation(fields: [journalEntryId], references: [id])
  Lot          Lot[]
  LotDisposal  LotDisposal[]

  @@unique([chain, network, txHash, logIndex])
  @@index([chain, network, blockNumber])
  @@index([processed])
  @@index([from])
  @@index([to])
  @@index([blockTimestamp])
}

model ClassificationRule {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?
  priority    Int     @default(0)

  // Conditions (JSON logic)
  conditions Json // { "direction": "inbound", "from": ["0x123..."] }

  // Actions
  actions Json // [{ "type": "mark_trade", "params": {...} }]

  isActive Boolean @default(true)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  @@index([priority])
}

model Price {
  id    String @id @default(cuid())
  asset String // "BTC", "ETH", "USDC"
  quote String // "USD", "EUR"

  timestamp DateTime
  value     Float
  source    String // "coingecko", "chainlink", "manual"

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  @@unique([asset, quote, timestamp, source])
  @@index([asset, quote, timestamp])
  @@index([timestamp])
}

model Lot {
  id          String @id @default(cuid())
  asset       String
  quantity    Float
  costBasis   Float // Total cost in functional currency
  costPerUnit Float

  // Acquisition
  acquiredAt     DateTime
  acquiredFrom   String? // "purchase", "mining", "staking", etc.
  sourceEventId  String? // BlockchainEvent ID
  journalEntryId String?

  // Current state
  remainingQty Float
  disposed     Boolean @default(false)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  sourceEvent  BlockchainEvent? @relation(fields: [sourceEventId], references: [id])
  journalEntry JournalEntry?    @relation("LotSource", fields: [journalEntryId], references: [id])
  disposals    LotDisposal[]

  @@index([asset, disposed])
  @@index([acquiredAt])
}

model LotDisposal {
  id    String @id @default(cuid())
  lotId String

  quantityDisposed Float
  proceedsPerUnit  Float
  totalProceeds    Float

  costBasisPerUnit Float
  totalCostBasis   Float

  // Realized P&L
  realizedPnL Float

  disposedAt      DateTime
  disposalEventId String?
  journalEntryId  String?

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  lot           Lot              @relation(fields: [lotId], references: [id], onDelete: Cascade)
  disposalEvent BlockchainEvent? @relation(fields: [disposalEventId], references: [id])
  journalEntry  JournalEntry?    @relation("LotDisposal", fields: [journalEntryId], references: [id])

  @@index([lotId])
  @@index([disposedAt])
}

// ============================================================================
// MULTI-ENTITY CONSOLIDATION
// ============================================================================

model Entity {
  id       String @id @default(cuid())
  code     String @unique
  name     String
  currency String // Functional currency

  entityType String // "parent", "subsidiary", "branch"
  country    String?
  taxId      String?

  parentEntityId String?

  isActive  Boolean  @default(true)
  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent           Entity?                @relation("EntityHierarchy", fields: [parentEntityId], references: [id])
  children         Entity[]               @relation("EntityHierarchy")
  accounts         Account[]
  intercompanyFrom IntercompanyRelation[] @relation("EntityFrom")
  intercompanyTo   IntercompanyRelation[] @relation("EntityTo")
  issuedInvoices   Invoice[]
  bankAccounts     BankAccount[]
}

model IntercompanyRelation {
  id           String @id @default(cuid())
  fromEntityId String
  toEntityId   String

  relationType String // "parent_sub", "sister", "branch"

  // Elimination accounts
  receivableAccountId String?
  payableAccountId    String?

  isActive  Boolean  @default(true)
  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  fromEntity Entity @relation("EntityFrom", fields: [fromEntityId], references: [id])
  toEntity   Entity @relation("EntityTo", fields: [toEntityId], references: [id])

  @@unique([fromEntityId, toEntityId])
  @@index([fromEntityId])
  @@index([toEntityId])
}

model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency String
  toCurrency   String
  date         DateTime
  rate         Float

  source String @default("manual") // "manual", "ecb", "fed"

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  @@unique([fromCurrency, toCurrency, date])
  @@index([fromCurrency, toCurrency, date])
}

model ConsolidationRun {
  id                String @id @default(cuid())
  period            String // "2025-01"
  reportingCurrency String @default("USD")

  // Results
  consolidatedData Json // Trial balance, eliminations, etc.

  status String @default("completed") // "running", "completed", "failed"

  metadata    Json      @default("{}")
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@unique([period, reportingCurrency])
  @@index([period])
}

// ============================================================================
// TAX COMPLIANCE - Spanish Facturae & SII
// ============================================================================

model Invoice {
  id            String   @id @default(cuid())
  invoiceNumber String   @unique
  invoiceDate   DateTime

  // Type
  invoiceType String // "380" (invoice), "381" (credit note)
  direction   String // "issued", "received"

  // Parties
  supplierId String
  customerId String

  // Amounts
  subtotal  Float
  taxAmount Float
  total     Float
  currency  String @default("EUR")

  // Payment
  dueDate       DateTime?
  paymentMethod String?

  // Facturae (Spain)
  facturaeFiled     Boolean @default(false)
  facturaeXml       String? @db.Text
  facturaeSignature String? @db.Text

  // SII (Spain)
  siiStatus      String? // "pending", "submitted", "accepted", "rejected"
  siiSubmittedAt DateTime?
  siiResponse    Json?

  // Peppol (EU)
  ublXml       String? @db.Text
  ublValidated Boolean @default(false)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  supplier       Party         @relation("SupplierInvoices", fields: [supplierId], references: [id])
  customer       Party         @relation("CustomerInvoices", fields: [customerId], references: [id])
  lines          InvoiceLine[]
  journalEntry   JournalEntry? @relation(fields: [journalEntryId], references: [id])
  journalEntryId String?
  Entity         Entity?       @relation(fields: [entityId], references: [id])
  entityId       String?

  @@index([invoiceNumber])
  @@index([invoiceDate])
  @@index([siiStatus])
}

model InvoiceLine {
  id        String @id @default(cuid())
  invoiceId String

  lineNumber  Int
  description String
  quantity    Float
  unitPrice   Float
  discount    Float  @default(0)

  subtotal  Float
  taxRate   Float
  taxAmount Float
  total     Float

  metadata Json @default("{}")

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
}

model Party {
  id    String @id @default(cuid())
  taxId String @unique // NIF/CIF/VAT
  name  String

  address    String?
  city       String?
  postalCode String?
  country    String  @default("ES")

  email String?
  phone String?

  isCustomer Boolean @default(false)
  isSupplier Boolean @default(false)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  issuedInvoices   Invoice[] @relation("SupplierInvoices")
  receivedInvoices Invoice[] @relation("CustomerInvoices")

  @@index([taxId])
}

// ============================================================================
// RECONCILIATION - Bank & Wallet
// ============================================================================

model BankAccount {
  id            String @id @default(cuid())
  accountNumber String @unique
  bankName      String
  currency      String @default("EUR")

  glAccountId String
  entityId    String?

  isActive  Boolean  @default(true)
  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  glAccount       Account              @relation(fields: [glAccountId], references: [id])
  entity          Entity?              @relation(fields: [entityId], references: [id])
  statements      BankStatement[]
  reconciliations BankReconciliation[]

  @@index([accountNumber])
  @@index([glAccountId])
}

model BankStatement {
  id            String @id @default(cuid())
  bankAccountId String

  statementDate  DateTime
  openingBalance Float
  closingBalance Float

  // File info
  filename   String?
  importedAt DateTime @default(now())

  metadata Json @default("{}")

  bankAccount  BankAccount       @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  transactions BankTransaction[]

  @@index([bankAccountId, statementDate])
}

model BankTransaction {
  id          String @id @default(cuid())
  statementId String

  transactionDate DateTime
  valueDate       DateTime
  amount          Float
  description     String
  reference       String?

  // Reconciliation
  matched        Boolean @default(false)
  matchedEntryId String?
  matchScore     Float?

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  statement      BankStatement       @relation(fields: [statementId], references: [id], onDelete: Cascade)
  matchedEntry   JournalEntry?       @relation(fields: [matchedEntryId], references: [id])
  reconciliation BankReconciliation?

  @@index([statementId])
  @@index([matched])
  @@index([transactionDate])
}

model BankReconciliation {
  id                String @id @default(cuid())
  bankAccountId     String
  bankTransactionId String @unique

  reconciledAt DateTime @default(now())
  reconciledBy String?

  matchType  String // "automatic", "manual", "suggested"
  confidence Float  @default(0)

  notes String?

  metadata Json @default("{}")

  bankAccount     BankAccount     @relation(fields: [bankAccountId], references: [id])
  bankTransaction BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)

  @@index([bankAccountId])
  @@index([reconciledAt])
}

// ============================================================================
// ANALYTICS & METRICS
// ============================================================================

model ColumnarSnapshot {
  id          String   @id @default(cuid())
  asOfDate    DateTime
  recordCount Int
  duckdbPath  String

  // Metadata
  createdAt DateTime @default(now())
  createdBy String?
  fileSize  BigInt?

  metadata Json @default("{}")

  @@unique([asOfDate])
  @@index([asOfDate])
}

model Anomaly {
  id       String @id @default(cuid())
  type     String // "unusual_amount", "balance_spike", "frequency_anomaly"
  severity String // "low", "medium", "high", "critical"

  // Detection
  detectedAt   DateTime @default(now())
  resourceType String // "entry", "account", "transaction"
  resourceId   String

  // Details
  title       String
  description String
  metrics     Json // Statistical details

  // Status
  status     String    @default("open") // "open", "investigating", "resolved"
  resolvedAt DateTime?
  resolvedBy String?
  resolution String?

  metadata Json @default("{}")

  @@index([type, severity])
  @@index([status])
  @@index([detectedAt])
}

model FinancialMetric {
  id         String @id @default(cuid())
  metricType String // "burn_rate", "runway", "cash_ratio"
  period     String // "daily", "weekly", "monthly"

  asOfDate      DateTime
  value         Float
  previousValue Float?
  changePercent Float?

  dimensions Json?
  metadata   Json     @default("{}")
  createdAt  DateTime @default(now())

  @@unique([metricType, period, asOfDate])
  @@index([metricType, asOfDate])
}

// ============================================================================
// AUTHENTICATION & AUTHORIZATION
// ============================================================================

model User {
  id           String @id @default(cuid())
  email        String @unique
  passwordHash String

  firstName String?
  lastName  String?

  isActive      Boolean @default(true)
  emailVerified Boolean @default(false)

  lastLoginAt DateTime?

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles         UserRole[]
  refreshTokens RefreshToken[]
  auditLogs     AuditLog[]

  @@index([email])
}

model Role {
  id          String  @id @default(cuid())
  name        String  @unique // "admin", "accountant", "auditor", "viewer"
  description String?

  permissions Json // Array of permission objects

  isActive Boolean @default(true)

  metadata  Json     @default("{}")
  createdAt DateTime @default(now())

  users UserRole[]

  @@index([name])
}

model UserRole {
  id     String @id @default(cuid())
  userId String
  roleId String

  assignedAt DateTime @default(now())
  assignedBy String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

model RefreshToken {
  id     String @id @default(cuid())
  userId String
  token  String @unique

  expiresAt DateTime
  createdAt DateTime @default(now())

  revokedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
}

model AuditLog {
  id     String  @id @default(cuid())
  userId String?

  action     String // "create", "update", "delete", "read"
  resource   String // "entry", "account", "invoice"
  resourceId String?

  changes   Json? // Before/after for updates
  ipAddress String?
  userAgent String?

  timestamp DateTime @default(now())

  metadata Json @default("{}")

  user User? @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([resource, resourceId])
  @@index([timestamp])
}
